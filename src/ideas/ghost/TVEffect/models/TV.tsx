/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import * as THREE from "three";
import { Vector3 } from "three";

import { shaderMaterial } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { extend, useFrame, GroupProps } from "@react-three/fiber";
import { useLimiter, useModel } from "spacesvr";
import { useDistortMat } from "../logic/distorMat";

type GLTFResult = GLTF & {
  nodes: {
    screen: THREE.Mesh;
    "TV-Mat": THREE.Mesh;
    "TV-Mat2": THREE.Mesh;
    "TV-Mat001": THREE.Mesh;
    "NEs-Mat": THREE.Mesh;
    "NEs-Mat1": THREE.Mesh;
    "NEs-Mat2": THREE.Mesh;
    "NEs-Mat3": THREE.Mesh;
  };
  materials: {
    ["Mat2"]: THREE.MeshStandardMaterial;
    ["Mat1"]: THREE.MeshStandardMaterial;
    ["Mat3"]: THREE.MeshStandardMaterial;
    ["Mat4"]: THREE.MeshStandardMaterial;
    ["TVMat1"]: THREE.MeshStandardMaterial;
    ["TVMat2"]: THREE.MeshStandardMaterial;
    Mat: THREE.MeshStandardMaterial;
  };
};

type ModelProps = JSX.IntrinsicElements["group"];

const fileURL =
  "https://d1htv66kutdwsl.cloudfront.net/284a7d50-b70f-4afe-8642-f56d62c2c984/8025c333-33ac-41b7-916e-8a83e954be61.glb";

export function TV(props: ModelProps) {
  const { nodes, materials } = useModel(fileURL) as GLTFResult;
  const distortMat = useDistortMat(0.5);
  const portalMaterial = useRef();
  const mesh = useRef();

  // useFrame((state, delta) => {
  //   mesh.current.material.uniforms.time.value += delta
  // })

  return (
    <group {...props} dispose={null}>
      <group position={[0, 0, 49.13]}>
        <mesh ref={mesh} geometry={nodes.screen.geometry}>
          {/* <creationMaterial resolution={30, 30, 1]} /> */}
        </mesh>
        <mesh geometry={nodes["TV-Mat"].geometry} material={materials.TVMat1} />
        <mesh
          geometry={nodes["TV-Mat2"].geometry}
          material={materials.TVMat2}
        />
      </group>
    </group>
  );
}

const CreationMaterial = shaderMaterial(
  {
    time: 0,
    resolution: new Vector3(),
  },
  `
varying vec2 vUv;

void main()	{
  vUv = uv;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
}
`,
  `
uniform vec3 resolution;
uniform float time;

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
	vec3 c;
	float l, z = time;

	for(int i=0;i<10;i++) {
		vec2 uv, p = fragCoord.xy/resolution.xy;
		uv = p;
		p -= .5;
		p.x *= resolution.x / resolution.y;
		z += 2.0;
		l = length(p);
		uv += p / l * (sin(z / 2.) + 1.) * abs(sin(l * 3. - z * .5));
		c[i] = .01 / length(abs(mod(uv, 1.) -.5));
	}

	fragColor = vec4(c / l, time / 2.);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
`
);

extend({ CreationMaterial });
